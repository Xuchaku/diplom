{"modules":[{"name":"Не дерево","desc":"определяет ялвяется ли граф не деревом","type":"boolean","script":"(function a(){let cnt = graph.getCountNodes(); let rbr = graph.getCountPath(); let val = graph.isTree(); return (cnt - rbr == 1) && !val;})","nameFunction":"a()","idHash":1601659710,"verif":"ok"},{"name":"Другой модуль","desc":"Описание данного модуля","type":"boolean","script":"(function b(){function a(){let cnt = graph.getCountNodes(); let rbr = graph.getCountPath(); let val = graph.isTree(); return (cnt - rbr == 1) && !val;}let cnt = graph.getCountNodes(); let val = a(); return val && cnt;})","nameFunction":"b()","idHash":-952985243,"verif":"ok"},{"name":"Двойное кол-во","desc":"Данный модуль возвращает двойное кол-во вершин","type":"integer","script":"(function somename(){let cnt = graph.getCountNodes();return cnt})","nameFunction":"somename()","idHash":-1902244967,"verif":"ok"},{"name":"Двойное кол-во","desc":"Данный модуль возвращает двойное кол-во вершин","type":"integer","script":"(function vasya(){function a(){let cnt = graph.getCountNodes(); let rbr = graph.getCountPath(); let val = graph.isTree(); return (cnt - rbr == 1) && !val;}let cnt = graph.getCountNodes();return cnt*3;})","nameFunction":"vasya()","idHash":319552183,"verif":"ok"},{"name":"Плоский","desc":"Данный модуль оперделяет плоский ли граф","type":"boolean","script":"(function plsk(){\n    let parts = [];\n    let nodesCheck = [];\n    function dfs(key){\n        nodesCheck.push(key);\n        for(let i = 0;i<graph.nodeHash[key].roads.length;i++){\n            parts.push([graph.nodeHash[key].x, graph.nodeHash[key].y, graph.nodeHash[graph.nodeHash[key].roads[i].to].x, graph.nodeHash[graph.nodeHash[key].roads[i].to].y]);\n            //dfs(graph.nodeHash[key].roads[i].to);\n        }\n    }\n    for(let key in graph.nodeHash){\n        if(!nodesCheck.includes(key))\n            dfs(key);\n    }\n    console.log(parts);\n    let summ = false;\n\n    for(let i=0; i < parts.length; i++){\n        for(let j=i+1; j < parts.length; j++){\n            let ax1 = parts[i][0]\n            let ay1 = parts[i][1]\n            let ax2 = parts[i][2]\n            let ay2 = parts[i][3]\n            let bx1 = parts[j][0]\n            let by1 = parts[j][1]\n            let bx2 = parts[j][2]\n            let by2 = parts[j][3]\n\n\n            let v1=(bx2-bx1)*(ay1-by1)-(by2-by1)*(ax1-bx1);\n            let v2=(bx2-bx1)*(ay2-by1)-(by2-by1)*(ax2-bx1);\n            let v3=(ax2-ax1)*(by1-ay1)-(ay2-ay1)*(bx1-ax1);\n            let v4=(ax2-ax1)*(by2-ay1)-(ay2-ay1)*(bx2-ax1);\n            let intersection=(v1*v2<0)&&(v3*v4<0);\n\n            summ += intersection\n\n        }\n\n    }\n    return !summ;\n})","nameFunction":"plsk()","idHash":1533635827,"verif":"ok"}]}